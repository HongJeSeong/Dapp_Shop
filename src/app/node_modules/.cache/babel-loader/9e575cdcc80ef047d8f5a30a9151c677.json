{"ast":null,"code":"'use strict';\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar fs = require('fs');\n\nvar ethabi = require('ethereumjs-abi');\n\nvar ethers = require('ethers');\n\nvar Buffer = require('buffer/').Buffer;\n\nvar isBuffer = require('is-buffer');\n\nvar InputDataDecoder = function () {\n  function InputDataDecoder(prop) {\n    _classCallCheck(this, InputDataDecoder);\n\n    this.abi = [];\n\n    if (typeof prop === 'string') {\n      this.abi = JSON.parse(fs.readFileSync(prop));\n    } else if (prop instanceof Object) {\n      this.abi = prop;\n    } else {\n      throw new TypeError('Must pass ABI array object or file path to constructor');\n    }\n  }\n\n  _createClass(InputDataDecoder, [{\n    key: 'decodeConstructor',\n    value: function decodeConstructor(data) {\n      if (isBuffer(data)) {\n        data = data.toString('utf8');\n      }\n\n      if (typeof data !== 'string') {\n        data = '';\n      }\n\n      data = data.trim();\n\n      for (var i = 0; i < this.abi.length; i++) {\n        var obj = this.abi[i];\n\n        if (obj.type !== 'constructor') {\n          continue;\n        }\n\n        var method = obj.name || null;\n        var types = obj.inputs ? obj.inputs.map(function (x) {\n          return x.type;\n        }) : [];\n        var names = obj.inputs ? obj.inputs.map(function (x) {\n          return x.name;\n        }) : []; // take last 32 bytes\n\n        data = data.slice(-256);\n\n        if (data.length !== 256) {\n          throw new Error('fail');\n        }\n\n        if (data.indexOf('0x') !== 0) {\n          data = '0x' + data;\n        }\n\n        var inputs = ethers.utils.defaultAbiCoder.decode(types, data);\n        return {\n          method: method,\n          types: types,\n          inputs: inputs,\n          names: names\n        };\n      }\n\n      throw new Error('not found');\n    }\n  }, {\n    key: 'decodeData',\n    value: function decodeData(data) {\n      if (isBuffer(data)) {\n        data = data.toString('utf8');\n      }\n\n      if (typeof data !== 'string') {\n        data = '';\n      }\n\n      data = data.trim();\n      var dataBuf = Buffer.from(data.replace(/^0x/, ''), 'hex');\n      var methodId = toHexString(dataBuf.subarray(0, 4));\n      var inputsBuf = dataBuf.subarray(4);\n      var result = this.abi.reduce(function (acc, obj) {\n        if (obj.type === 'constructor') return acc;\n        if (obj.type === 'event') return acc;\n        var method = obj.name || null;\n        var types = obj.inputs ? obj.inputs.map(function (x) {\n          if (x.type.includes('tuple')) {\n            return x;\n          } else {\n            return x.type;\n          }\n        }) : [];\n        var names = obj.inputs ? obj.inputs.map(function (x) {\n          if (x.type.includes('tuple')) {\n            return [x.name, x.components.map(function (a) {\n              return a.name;\n            })];\n          } else {\n            return x.name;\n          }\n        }) : [];\n        var hash = genMethodId(method, types);\n\n        if (hash === methodId) {\n          var inputs = [];\n\n          try {\n            inputsBuf = normalizeAddresses(types, inputsBuf);\n            inputs = ethabi.rawDecode(types, inputsBuf);\n          } catch (err) {\n            inputs = ethers.utils.defaultAbiCoder.decode(types, inputsBuf); // defaultAbiCoder attaches some unwanted properties to the list object\n\n            inputs = deepRemoveUnwantedArrayProperties(inputs); // TODO: do this normalization into normalizeAddresses\n\n            inputs = inputs.map(function (input, i) {\n              if (types[i].components) {\n                var tupleTypes = types[i].components;\n                return deepStripTupleAddresses(input, tupleTypes);\n              }\n\n              if (types[i] === 'address') {\n                return input.split('0x')[1];\n              }\n\n              if (types[i] === 'address[]') {\n                return input.map(function (address) {\n                  return address.split('0x')[1];\n                });\n              }\n\n              return input;\n            });\n          } // Map any tuple types into arrays\n\n\n          var typesToReturn = types.map(function (t) {\n            if (t.components) {\n              var arr = t.components.reduce(function (acc, cur) {\n                return [].concat(_toConsumableArray(acc), [cur.type]);\n              }, []);\n              var tupleStr = '(' + arr.join(',') + ')';\n              if (t.type === 'tuple[]') return tupleStr + '[]';\n              return tupleStr;\n            }\n\n            return t;\n          });\n          return {\n            method: method,\n            types: typesToReturn,\n            inputs: inputs,\n            names: names\n          };\n        }\n\n        return acc;\n      }, {\n        method: null,\n        types: [],\n        inputs: [],\n        names: []\n      });\n\n      if (!result.method) {\n        try {\n          var decoded = this.decodeConstructor(data);\n\n          if (decoded) {\n            return decoded;\n          }\n        } catch (err) {}\n      }\n\n      return result;\n    }\n  }]);\n\n  return InputDataDecoder;\n}(); // remove 0x from addresses\n\n\nfunction deepStripTupleAddresses(input, tupleTypes) {\n  return input.map(function (item, i) {\n    var type = tupleTypes[i].type;\n\n    if (type === 'address' && typeof item === 'string') {\n      return item.split('0x')[1];\n    }\n\n    if (type === 'address[]' || Array.isArray()) {\n      return item.map(function (a) {\n        return a.split('0x')[1];\n      });\n    }\n\n    return item;\n  });\n}\n\nfunction deepRemoveUnwantedArrayProperties(arr) {\n  return [].concat(_toConsumableArray(arr.map(function (item) {\n    if (Array.isArray(item)) return deepRemoveUnwantedArrayProperties(item);\n    return item;\n  })));\n}\n\nfunction normalizeAddresses(types, input) {\n  var offset = 0;\n\n  for (var i = 0; i < types.length; i++) {\n    var type = types[i];\n\n    if (type === 'address') {\n      input.set(Buffer.alloc(12), offset);\n    }\n\n    if (isArray(type)) {\n      var size = parseTypeArray(type);\n\n      if (size && size !== 'dynamic') {\n        offset += 32 * size;\n      } else {\n        offset += 32;\n      }\n    } else {\n      offset += 32;\n    }\n  }\n\n  return input;\n}\n\nfunction parseTypeArray(type) {\n  var tmp = type.match(/(.*)\\[(.*?)\\]$/);\n\n  if (tmp) {\n    return tmp[2] === '' ? 'dynamic' : parseInt(tmp[2], 10);\n  }\n\n  return null;\n}\n\nfunction isArray(type) {\n  return type.lastIndexOf(']') === type.length - 1;\n}\n\nfunction handleInputs(input, tupleArray) {\n  if (input instanceof Object && input.components) {\n    input = input.components;\n  }\n\n  if (!Array.isArray(input)) {\n    if (input instanceof Object && input.type) {\n      return input.type;\n    }\n\n    return input;\n  }\n\n  var ret = '(' + input.reduce(function (acc, x) {\n    if (x.type === 'tuple') {\n      acc.push(handleInputs(x.components));\n    } else if (x.type === 'tuple[]') {\n      acc.push(handleInputs(x.components) + '[]');\n    } else {\n      acc.push(x.type);\n    }\n\n    return acc;\n  }, []).join(',') + ')';\n\n  if (tupleArray) {\n    return ret + '[]';\n  }\n\n  return ret;\n}\n\nfunction genMethodId(methodName, types) {\n  var input = methodName + '(' + types.reduce(function (acc, x) {\n    acc.push(handleInputs(x, x.type === 'tuple[]'));\n    return acc;\n  }, []).join(',') + ')';\n  return ethers.utils.keccak256(Buffer.from(input)).slice(2, 10);\n}\n\nfunction toHexString(byteArray) {\n  return Array.from(byteArray, function (_byte) {\n    return ('0' + (_byte & 0xFF).toString(16)).slice(-2);\n  }).join('');\n}\n\nmodule.exports = InputDataDecoder;","map":null,"metadata":{},"sourceType":"script"}